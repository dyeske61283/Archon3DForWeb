% !TeX root = ../Bachelorarbeit.tex
\chapter{Hauptteil}
\label{cha:Hauptteil}

\section{Einleitung}
Die Anforderungen an eine Neuauflage von "Archon" werden durch eine vorhergehende Analyse des Spiels und seiner einzelnen Komponenten und Mechaniken herausgearbeitet.\\
Anschließend werden die Möglichkeiten und Optionen der zu benutzenden Technologien analysiert und eine Verbindung zu den Spielmechaniken hergestellt.

\section{Analyse}
\label{sec:analyse}\index{Analyse}

\subsection{Analyse des klassischen Spiels}
\label{subsec:spiel_analyse}\index{Spiel Analyse}
In diesem Abschnitt werden die Anforderungen und Regeln aus Archon herausgearbeitet. Die Anforderungen und Regeln werden, der Übersicht halber, in folgende Kategorien unterteilt: 
\begin{itemize}
	\item Generelle Regeln und Ziele des Spiels
	\item Das Spielbrett
	\item Das Kampfareal
	\item Die Figuren
	\item Die Zauber
\end{itemize}
Die folgenden Abschnitte enthalten eine kurze Zusammenfassung des Spiels und seinen Inhalten und Regeln anhand der obigen Aufteilung. Anschließend wird herausgearbeitet, welche Eigenschaften eine Realisierung des Spiels inne haben muss, um das Spiel ausreichend widerzuspiegeln. 
\subsubsection{Generelle Regeln und Ziele des Spiels}
Archon ist ein Spiel, dass auf einem 9 x 9 Schachbrett stattfindet. Ähnlich wie beim Schach gibt es zwei Parteien, Licht und Dunkelheit, die sich im Wettstreit gegenüberstehen.
Die Spieler ziehen dabei immer abwechselnd ihre Figuren auf dem Spielbrett, wobei kein Zug gepasst werden kann. Jeder Spieler beginnt mit 18 Figuren, die in acht verschiedene Typen gegliedert sind. Die Figuren von Licht und Dunkelheit sind vollständig unterschiedlich. Treffen zwei Figuren auf dem Spielbrett zusammen, stehen sie sich in einem Kampfareal gegenüber. Jede Figur hat dabei ihre eigenen Lebenspunkte und ihre eigene Angriffsstärke. Der Sieger dieses Kampfes bleibt auf dem Spielbrett, während der Verlierer aus dem Spiel genommen wird. Sollte der Kampf in einem Unentschieden ausgehen, werden beide Figuren aus dem Spiel genommen.
\\Das generelle Ziel des Spiels ist es alle 5 speziellen Machtfelder gleichzeitig mit eigenen Figuren zu besetzen.
Desweiteren kann das Spiel gewonnen werden, indem alle gegenerischen Figuren besiegt werden oder die letzte Figur mit einem Gefängnis-Zauber belegt wird.
Ein Unentschieden tritt auf wenn das Spiel zu lange passiv ist, also wenn für mindestens zwölf Züge kein Kampf stattfindet und kein Zauber gewirkt wird.\\
Das Spiel kann in folgenden Modi gestartet werden: 
\begin{itemize}
	\item Spieler gegen Spieler
	\item Spieler gegen Computer
	\item Computer gegen Computer (Demo-Modus)
\end{itemize}
Wobei der erste Spieler immer die Wahl der startenden Farbe, sowie der eigenen Farbe hat.\\Weitere Einstellmöglichkeiten gibt es nicht.

\subsubsection{Das Spielbrett}
\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.50\textwidth]{ArchonStrategiieBildschirm}
	\caption[Das Spielbrett]{Das Spielbrett \footnotemark}
	\label{fig:StrategyBoard}
\end{figure}
\footnotetext{\Quelle{C64-Wiki, \url{https://www.c64-wiki.com/wiki/File:ArchonStrategiieBildschirm.gif}}}
Das Spielbrett besteht aus 9x9 Feldern von drei Typen: 
\begin{itemize}
	\item Permanent weiße Felder
	\item Permanent schwarze Felder
	\item Felder, die zwischen Schwarz, vier anderen Farben und Weiß wechseln
\end{itemize}
Alle farbwechselnden Felder ändern ihre Farbe nach dem Zug des zweiten Spielers, sodass jeder Spieler einen Zug der gleichen Farbfelder hat. Ein Farbzyklus dauert damit zwölf Züge pro Seite: Sechs von Weiß zu Schwarz und Sechs zurück.
Da sich die mittleren vier Farben je nach Ableger unterscheiden können, werden sie fortan mit Zahlen von 1 bis 6 durchnummeriert, wobei 1 Weiß darstellt und 6 Schwarz.
Wenn die Licht-Seite das Spiel beginnt, startet der Farbzyklus bei Farbe 4 und wird dunkler. Beginnt die Dunkelheit-Seite, so startet der Zyklus bei Farbe 3 und wird heller. Die Farbe der Felder gibt den darauf stehenden Figuren einen Lebenspunkte-Bonus, der größer ausfällt, je näher die Feld-Farbe an der Team-Farbe der Figur ist.
\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.40\textwidth]{archon_colorchart.png}
	\caption[Lebenspunkte-Bonus]{Lebenspunkte-Bonus anhand der Feldfarben\footnotemark}
	\label{fig:HP-Bonus}
\end{figure}
\footnote{\Quelle{vintagecomputing, \url{http://www.vintagecomputing.com/wp-content/images/archon/archon_colorchart.gif}}}
Weiterhin gibt es die fünf Machtfelder, deren Einnahme die Siegbedingung darstellt. Diese Felder haben außerdem zwei spezielle Effekte auf Figuren, die darauf stehen. Zum einen können darauf stehende Figuren -- und auch die Felder an sich, nicht Ziel eines Zaubers werden. Zum Anderen werden die Figuren nach jedem eigenen Zug um einen gewissen Betrag geheilt, sollten sie im Kampf verletzt worden sein. Diese fünf Machtfelder verteilen sich so, dass jeweils eines auf einem permanent schwarzen bzw. weißen Feld ist - dort wo der Zauberer bzw. die Zauberin ihre Ausgangsposition haben. Die anderen drei Felder sind auf farbwechselnden Feldern in der Mitte des Spielbretts verteilt.

\subsubsection{Das Kampfareal}
\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.40\textwidth]{archon_battlescreen_small}
	\caption[Kampfareal]{Das Kampfareal}
	\label{fig:Battlescreen}
\end{figure}
\noindent Das Kampfareal erscheint wenn zwei Figuren auf dem Spielbrett aufeinander treffen. Es stellt eine große Fläche dar, bei der von Zeit zu Zeit pflanzenähnliche Hindernisse erscheinen und wieder verschwinden. An den Seiten des Kampfareals werden die Lebenspunkte der kämpfenden Figuren in Form von Balken dargestellt.\\
Die Figuren können sich hier frei bewegen und haben, je nach Typ, unterschiedliche Eigenschaften, Attacken und Geschwindigkeiten.

\subsubsection{Die Figuren}
Das Spielbrett ist zu Spielbeginn mit 18 Spielfiguren pro Seite belegt. Es gibt 16 verschiedene Typen von Figuren, wobei die Typen von entsprechenden Figuren von Licht und Dunkelheit unterschiedlich sind. Die Beschreibung der Typen wird hier oberflächlich in Form einer Auflistung gestaltet, da die exakten Zahlenwerte der Lebenspunkte, Geschwindigkeiten und andere Eigenschaften bereits in einer anderen Zusammenfassung zu finden sind und an diesem Punkt für einen generellen Einblick in das Spiel nicht relevant sind.\footnote{Für mehr Details siehe: The secrets of Archon \url{http://www.vintagecomputing.com/index.php/archives/44}}
\begin{multicols}{2}
	Die Figuren des Lichts sind: 
	\begin{itemize}
		\item Ritter
		\item Bogenschütze
		\item Walküre
		\item Golem
		\item Einhorn
		\item Phönix
		\item Dschinn
		\item Zauberer
	\end{itemize}
\columnbreak
	Die Figuren der Dunkelheit sind:
	\begin{itemize}
		\item Goblin
		\item Mantikor
		\item Banshee
		\item Troll
		\item Basilisk
		\item Gestaltwandler
		\item Drache
		\item Zauberin
	\end{itemize}
\end{multicols}
\noindent Sich gegenüber stehende Figuren-Klassen in dieser Auflistung entsprechen sich in etwa in ihrer Stärke. Die Figuren haben dabei auch auf dem Spielbrett unterschiedliche Eigenschaften, so können Boden-Figuren, wie der Troll oder der Ritter, nicht über andere Figuren hinweg gesetzt werden und nicht diagonal bewegt werden. Je nach Typ ist die Bewegungsreichweite unterschiedlich: Drache und Dschinn können beispielsweise bis zu 4 Felder bewegt werden, während die Walküre und die Banshee nur 3 Felder bewegt werden können.\\
Außerdem kann mit Hilfe eines Zaubers einer von vier Elementaren einmal pro Seite und Spiel beschworen werden. Sollte ein Elementar beschworen werden wird er aus der Liste der möglichen Elementare entfernt, sodass niemals in einem Spiel zwei gleiche Elementare beschworen werden können. Die vier Elementare sind nach den vier Elementen Feuer, Wasser, Erde und Luft eingeteilt und besitzen, ähnlich zu normalen Figuren, unterschiedliche Sprites\footnote{Sprite - graphisches Objekt, dass vor dem Hintergrund dargestellt wird, oft auch als Shape bezeichnet} und Werte. Welcher Elementar beschworen wird ist zufällig. Weiterhin bekommen Elementare keinen Lebenspunkte-Bonus von Feldfarben, sie haben also immer die gleichen Lebenspunkte.

\subsubsection{Die Zauber}
Der Zauberer und die Zauberin können, jeweils, einmal pro Spiel die folgenden sieben Zauber wirken:
\begin{itemize}
	\itemd{Teleportieren}
	Teleportiert eine eigene Figur auf ein Feld der eigenen Wahl. Sollte das Feld belegt sein, startet direkt ein Kampf.
	\itemd{Heilen}
	Heilt eine eigene, verwundete Figur vollständig.
	\itemd{Wiederbeleben}
	Belebt eine eigene, tote Figur wieder. Die Figur muss auf eines der umliegenden Felder des Zauberers \bzw der Zauberin platziert werden, egal wo sich die Figur befindet.
	\itemd{Tauschen}
	Tauscht die Position zweier Figuren -- unabhängig ihrer Farbe.
	\itemd{Zeitumkehr}
	Dreht den Farbzyklus um. Sollten die Felder jedoch Schwarz \bzw Weiß sein wenn der Zauber gewirkt wird, ändern sie ihre Farbe zur jeweils gegenteiligen Farbe beim nächsten Farbwechsel.
	\itemd{Bewegungsunfähigkeit}
	Eine Einheit wird unfähig gemacht Bewegungen auszuführen und Zauber zu wirken. Die Einheit bleibt bewegungsunfähig bis die Farb-Felder die eigene Team-Farbe erreicht haben. Die Einheit kann sich aber weiterhin normal im Kampfareal bewegen und angreifen.
	\itemd{Elementar beschwören}
	Beschwört einen Elementar auf ein auf ein besetztes Feld, sodass direkt ein Kampf stattfindet.
\end{itemize}
Das wirken eines Zaubers ist nicht auf Machtfelder möglich. Außerdem schwächt das Wirken jedes Zaubers den Lebenspunkte-Bonus auf dem Heimat-Feld des Zauberers bzw. der Zauberin um einen Punkt, sodass nach dem Wirken aller Zauber in einem Spiel der Bonus auf null Punkte geht.

\subsubsection{Zusammenfassung für die Realisierung}
Alle vorher genannten Aspekte des Spiels lassen sich in den Kern, der das Spiel ausmacht, zusammenfassen: Ein Strategiespiel auf einem 9x9 Schachbrett mit Action-Elementen in einem Kampfareal und verschieden starken Spielfiguren. Im folgenden werden die Aspekte herausgearbeitet, die eine große Priorität für eine Neuauflage inne haben. Dabei wird, ähnlich der Analyse, Komponentenweise vorgegangen.\\
Um eine ausreichende Schnittmenge mit dem Original zu haben und die neue Realisierung als "Ableger von Archon" bezeichnen zu können, sollten alle Aspekte unter "generelle Regeln und Ziele des Spiels" auf jeden Fall implementiert werden. Eine Ausnahme bildet hier die Auswahl der Spielmodi: Das Spiel an sich bietet zwar drei Modi an, jedoch ist es für eine erste Realisierung nur wichtig einen der Modi zu implementieren.\\
Das Spielbrett muss in seiner kompletten Funktionalität implementiert werden, da ganze Mechaniken sonst wegfallen und andere Mechaniken nutzlos werden. So zum Beispiel der Lebenspunkte-Bonus durch den Farbwechsel oder die Machtfelder als Einnahmepunkte mit speziellen Funktionen.\\
Das Kampfareal kann in einer ersten Version einfach implementiert sein. Wichtig ist hier nur das Vorhandensein an sich, sowie eine entsprechende Gewichtung der einzelnen Figuren nach ihrer Kampfkraft im Original.\\
Bei den Figuren sollte zumindest ein Typus implementiert sein. Es müssen nicht alle Figuren originalgetreu nachgebildet werden, sondern es sollte eine gewichtete Auswahl von Figuren geben, sodass ein Spiel zustandekommen kann. Das Aussehen kann dabei nach belieben angepasst werden um so der Realisierung ein eigenes Design zu geben. Wichtig ist hier, wieder einmal, nur die richtige Gewichtung von Kräften.
Die Zauber machen beim Original einen großen Teil der strategischen Mechanik aus, sodass sie vollständig zu implementieren sind. Die Zauber an kritischen Zeitpunkten im Spiel zu wirken macht jede einzelne Partie  Archon besonders. Der Stil der Zauber ist auch hier nicht wichtig, sondern ausschließlich ihre Funktion.
\subsection{Anforderungsanalyse an neue Realisierung}
\label{subsec:neueReal_analyse}\index{Analyse neue Realisierung}
Der Titel, sowie die Einleitung haben schon erläutert, dass bei dieser Realisierung zwei essentielle Technologien zum Einsatz kommen sollen: 
\begin{enumerate}
	\item 3D-Technologien
	\item Web-Technologien
\end{enumerate}
Dieser Abschnitt soll nun darstellen welche Aspekte der einzelnen Spiel-Funktionalitäten durch welche Technologie umgesetzt werden kann, oder ob es \evtl Hürden auf technologischer Ebene gibt, die durch Kompromisse in der Spiel-Mechanik gelöst werden müssen.
\subsubsection{Web-Technologien}
Da das Spiel mittels Web-Technologien realisiert werden soll, muss jegliche Kommunikation, unabhängig vom umgesetzten Modus, mittels Server-Client-Mechanismen gelöst werden können.


Die größten Anforderungen an Kommunikation stellt dabei der Action-Aspekt im Kampfareal dar. Hier wird Echtzeit-Kommunikation auf einem ziemlich hohen Niveau benötigt um möglichst kleine Latenzen zwischen Updates der Spielelemente zu vermeiden und so das Spiel überhaupt spielbar zu machen. Als Lösung für dieses Problem bietet sich der Websocket-Standard an, der von vielen Browsern unterstützt wird. Dieser Standard ermöglicht bidirektionale, asynchrone Kommunikation, ohne dass erneute TCP-Verbindungen aufgebaut werden müssen und damit kein großer Overhead\footnote{Overhead -- In der IT-Umgebung gängiger Begriff für Meta-Daten oder Programmcode der zusätzlich zur eigentlich Funktion ausgeführt oder versendet werden muss} entsteht. Der Client muss sich dazu einmalig mit einem Websocket unterstützenden Server verbinden. Über Websockets versendete Nachrichten können auch mit Objekten als Daten gefüllt werden, welche dann meist im JSON\footnote{JSON -- JavaScript Object Notation}-Format übertragen werden. Durch die weite Verbreitung des JSON-Formats ist die weitere Verarbeitung der Objekte stark vereinfacht und standardisiert.\\
Alle anderen Aspekte des Spiels sind sehr gut vereinbar mit einem webbasierten Server-Client-Modell:\\
Daten können vom Server vorgehalten und, falls nötig auch gespeichert werden. Dadurch wird keine Peer-to-Peer-Kommunikation\footnote{Peer-to-Peer -- Kommunikation zwischen gleichen End-Teilnehmern ohne einen Server als Medium} nötig und alle Synchronisation von Daten geschieht über den Webserver. Die gemeinsame Datenhaltung in einer Komponente hat weiterhin den Vorteil, dass viele Überprüfungen auf Konsistenz der Daten und Regeln des Spiels ebenfalls nur an einer einzigen Stelle implementiert werden müssen.
Die weitere Dynamisierung, also auch die Reaktion auf Eingaben eines Nutzers kann durch JavaScript und die Standard-DOM-API ausgeführt werden. Das erlaubt jede Kommunikation -- Server-Client und Spieler-Client über eine Schnittstelle abzufertigen.
Auf dem Client können Inhalte durch HTML\footnote{HTML -- Hypertext Markup Language ist eine Sprache um Dokumente im Webbrowser in ihrem Inhalt zu strukturieren }-Elemente repräsentiert und der Stil mittels CSS\footnote{CSS -- Cascading Style Sheets bilden die Regeln zum Aussehen von Webdokumenten}-Regeln angepasst werden.\\
Da aber auch 3D-Technologien in diese Realisierung einfließen sollen, bedarf es mehr als nur HTML und CSS zur Darstellung der Spielinhalte. Allein mit diesen Mitteln ist es sehr schwierig bis unmöglich teils komplexe Spielinhalte darzustellen.
\subsubsection{3D-Technologien}
Die Darstellung der Spielinhalte soll mittels 3D-Technologien stattfinden. Die Lösung für dieses Problem bieten "Canvas" und WebGL. Das HTML-Element "Canvas" ermöglicht es Inhalte im Webbrowser sehr frei zu gestalten. Das HTML-Element bietet dabei nur eine Leinwand (engl. Canvas) und die Inhalte werden mittels JavaScript programmiert. Gepaart mit dem WebGL-Standard ergibt sich die Möglichkeit vielfältige, aufwändige 3D-Darstellungen im Webbrowser zu synthetisieren. Denn:  Der WebGl-Standard erlaubt es ohne Erweiterungen hardwarebeschleunigte\footnote{Hardwarebeschleunigt -- Rechenintensive Aufgaben werden vom Hauptprozessor eines Computers an dafür dedizierte Hardware delegiert, heute vermehrt Grafikkarten und grafikintensive Aufgaben} 3D-Grafiken im Browser darzustellen. WebGL-Elemente können dabei beliebig mit herkömmlichen Webseiten-Elementen, also HTML und CSS, kombiniert werden.

Das "Canvas"-Element bildet also die Grundlage für eine mittels WebGL programmierte Szenerie des Spiels Archon, die mit Daten aus der Echtzeitkommunikation über den WebSocket-Standard gespeist wird. Da es, oberflächlich betrachtet, keinerlei Einschränkungen für eine Realisierung von Archon mittels der oben genannten Technologien gibt folgt nun die Implementierung des Spiels.
\section{Implementierung}
\label{sec:Umsetzung}\index{Implementierung}
Die Implementierung von Archon wird im Folgenden gezeigt. Dabei wird zunächst betrachtet, welche Frameworks, Software-Bibliotheken, Werkzeuge und Hilfsmittel benutzt werden und welche Vereinfachungen bezüglich des Spiels getroffen werden um den Entwicklungsaufwand und die Komplexität möglichst weit zu reduzieren. Anschließend wird aus den Anforderungen von Technologien und Spiel eine Grobarchitektur erstellt, die mit jedem Entwicklungsschritt verfeinert und \ggf angepasst wird.

\subsection{benötigte Technologien und Frameworks}
\label{subsec:Technologien}\index{Technologien}
Durch die bisherigen Ausarbeitungen steht fest, dass HTML, CSS und JavaScript zur Pflicht für die Implementierung des Clients werden um alle technologischen Anforderungen einhalten zu können. Desweiteren gibt es aber noch Bibliotheken, die die Entwicklung des Clients beschleunigen und vereinfachen, sowie den Umgang mit Websockets und WebGL erleichtern. Außerdem muss noch die Festlegung auf einen Webserver stattfinden, der bisher lediglich der Einschränkung bedarf, dass Websockets unterstützt werden müssen.

Die Liste an Webservern ist ähnlich groß, wie die von Programmiersprachen. Viele grundlegende Sprachen, wie die .NET-Umgebung, C++, PHP \ua unterstützen dabei über Bibliotheken oder Module auch den Websocket-Standard. Um die Entwicklung möglichst aufwandsarm zu gestalten und schnelle Fortschritte zu ermöglichen wurde sich in diesem Fall auf die node.js-Umgebung festgelegt, da hier der Server mittels JavaScript programmiert wird, was das zusätzliche Erlernen einer weiteren Programmiersprache und damit verbundene Kontext-Wechsel und Einarbeitungen in Eigenheiten, Bibliotheken und Programmiertechniken erspart.\\
Um die Entwicklung weiterhin zu beschleunigen wurde das Framework "Express" verwendet, welches es erlaubt auf einfachstem Weg über Routing-Mechanismen Webseiten-Anfragen eines Webservers zu beantworten.\\
Als Hilfsmittel für den Websocket-Standard wurde sich für Socket.io entschieden. Socket.io ist eine Library, welche Websockets wrapped und den Umgang stark vereinfacht. Socket.io erlaubt dabei eine stark Event-basierte Kommunikation, was dem Event-Emitter-Prinzip der node.js-Umgebung stark ähnelt und einen gleich Programmierstil ermöglicht. Die Library bietet ebenfalls einen Clientseitigen Teil an, welcher sich mit entsprechenden Optionen automatisch mit der Basis-Route des Webserver verbindet.\\
Für die Darstellung, also die Implementierung des WebGL-Standard wird three.js genutzt. three.js ist eine stark ausgebaute und weit verbreitete Library für Hochleistungs-3D-Entwicklung im Webbrowser. three.js besitzt weiterhin eine umfangreiche Dokumentation und eine sehr große Auswahl an Beispiel-Applikationen, welche den Einstieg und auch den weiteren Entwicklungsprozess beschleunigen. three.js arbeitet dabei mit einer Szene für die Zusammenfassung aller graphischen Objekte. Ein Kamera-Objekt legt den zu sehenden Ausschnitt der Szene fest und ein Renderer-Objekt zeichnet die Szene dann auf ein HTML-Canvas-Element. Dabei wird der bereits erwähnte WebGL-Standard als Kontext des Canvas benutzt. Um graphische Objekte zu erzeugen können dabei entweder Modelle mit populären Werkzeugen wie "Blender" oder "Maya" erzeugt und anschließend importiert werden, oder auch aus vorhandenen, primitiven Formen gebildet werden. Graphische Objekte bestehen dabei immer aus zwei Komponenten: Der Form (Geometry) und einem Material. Die Form gibt dabei die Eigenschaften wie Position, Skalierung und eben die einzelnen Punkte im 3D-Raum vor. Das Material entscheidet über die Interaktion mit Lichtquellen, sowie Farbe und Reflexion. Ein Objekt muss dabei nicht aus einem einzelnen Material bestehen. Außerdem können auch Bilder auf die Oberfläche von Formen projiziert werden. Da viele Projekte, die mit three.js implementiert wurden, frei verfügbar sind, findet man außerdem viele Beispielimplementierung, die auch produktiv im Einsatz sind.

Die node.js-Umgebung erlaubt es außerdem sogenannte Dev-Dependencies einzufügen, also Abhängigkeiten oder Bibliotheken, welche nur im Entwicklungsprozess benutzt werden und nicht in der Produktionsversion zu finden sind. Das folgende Kapitel befasst sich mit diesen Dev-Dependencies und anderen Hilftmitteln und Vereinfachungen für die Implementierung.
\subsection{Hilfsmittel und Vereinfachungen}
\label{subsec:Hilfsmittel}\index{Hilfsmittel}

\subsubsection{Dev-Dependencies}

Als größte Dev-Dependency sei an dieser Stelle TypeScript zu nennen. TypeScript ist ein sogenanntes Superset zu JavaScript: Jedes valide JavaScript-Programm ist also auch ein valides TypeScript-Programm. TypeScript wird direkt zu JavaScript mittels des Compilers tsc kompiliert. TypeScript fügt zu normalem JavaScript-Code statische Typen hinzu, sodass eine statische Analyse des Codes zur Kompilierzeit auf Fehler erfolgen kann, was die Sicherheit von Schnittstellen und Funktionsaufrufen erhöht. Zu TypeScript gehören als weitere Dev-Dependency die zugehörigen Typen-Deklarationen für bereits existierende JavaScript-Bibliotheken, sodass diese auch im TypeScript korrekt erkannt und von einer IDE\footnote{Integrated Development Environment -- Ein Entwicklungswerkzeug, dass die Aufgaben der Softwareentwicklung ohne Kontextwechsel erlaubt.} \bzw einem Code-Editor mit Auto-Vervollständigung genutzt werden können.

\subsubsection{Werkzeuge}

\subsubsection{Vereinfachungen}


\subsection{Architektur}
\label{subsec:Architektur}\index{Architektur}
The goal of every video game is to present the user(s) with a situation, accept their input, interpret those signals into actions, and calculate a new situation resulting from those acts. Games are constantly looping through these stages, over and over, until some end condition occurs (such as winning, losing, or exiting to go to bed). Not surprisingly, this pattern corresponds to how a game engine is programmed. The specifics depend on the game. \cite{https://developer.mozilla.org/en-us/docs/games/anatomy}

Der obige Paragraph sagt sehr genau aus, wie Spiele im allgemeinen aufgebaut sein sollten. Auch die Architektur dieser Realisierung orientiert sich daher an dem EVA\footnote{EVA -- Eingang-Verarbeitung-Ausgang}-Ansatz. 
Die Architektur folgt außerdem den Prinzipien einer objektorientieren Analyse. Aus dieser Analyse soll dann eine Software-Architektur entstehen, die alle Anforderungen vereint und einen möglichst gut wartbaren und erweiterbaren Rahmen darstellt.\\
Am Anfang einer objektorientieren Analyse steht meist ein Begriffsmodell, dass die Beziehungen einzelner Elemente aufzeigt, ohne sich direkt auf Code-Ebene zu bewegen. 
\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=1\textwidth]{Begriffsmodell}
	\caption[Begriffsmodell]{Begriffsmodell}
	\label{fig:Begriffsmodell}
\end{figure}
Die Abbildung \ref{fig:Begriffsmodell} stellt also die im Kapitel \ref{subsec:spiel_analyse} dargestellten Inhalte grafisch dar, was den Entwurf und die Zusammenhänge von Klassen und Objekten im Folgenden stark erleichtert. Das Begriffsmodel ist nur für die reine Spielelogik gültig und beinhaltet noch keinerlei Ansätze für den technologischen Aspekt der Architektur! Die folgenden Abschnitte sollen daher den Entwurf der generellen Systemarchitektur näher erläutern. Dabei wird, soweit möglich, noch nicht auf externe Abhängigkeiten eingegangen und die Architektur auch möglichst frei von konkreten Festlegungen auf Technologien und Frameworks gehalten. Am Ende dieses Kapitels werden die technologischen Abhängigkeiten aufgezeigt und mit in die Architektur integriert. Dieses Vorgehen erhöht die Übersicht stark und vereinfach die einzelnen Teilmodelle stark.

\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=1\textwidth]{ClientServer}
	\caption[Client-Server-Architektur]{Client-Server-Architektur}
	\label{fig:Client-Server-Architektur}
\end{figure}
Die Umsetzung mittels Webtechnologien verlangt es zwei generelle Komponenten zu entwickeln: Einen Webserver, sowie Clients welche sich mit dem Server verbinden.
Der Webserver und die Clients müssen dabei in beide Richtungen kommunizieren, was schematisch in Abbildung \ref{fig:Client-Server-Architektur} aufgezeigt ist.

\noindent Da die Darstellung des Spiels nur in den Clients erfolgt und im Server sich eine Datenhaltung mit entsprechenden Operationen zur Manipulation befindet, bietet sich ein Ansatz nach dem Model-View-Controller-Muster (MVC) an. Bei MVC handelt es sich um ein klassisches Entwurfsmuster der Softwareentwicklung, dass Abhängigkeiten reduzieren und Funktionalitäten kapseln soll. Das Entwurfsmuster sieht dabei vor die wesentlichen Aufgaben von Applikationen so aufzutrennen, dass die Ansicht, in den meisten Fällen eine graphische Benutzeroberfläche, möglichst unabhängig von den zugrunde liegenden Daten, also dem (Daten-)Modell ist. Dazu wird eine Klasse zur Kommunikation, der Controller, von Daten und Ansicht erstellt. Der Controller sorgt dabei dafür, dass Kommandos vom Benutzer, also in der Ansicht, an die Daten und dazugehörige Operationen weitergeleitet werden.
\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=1\textwidth]{MVC-Architektur}
	\caption[MVC]{Darstellung der MVC-Architektur mit Aufgaben}
	\label{fig:MVC}
\end{figure}
Hier wurde eine klassische Interpretierung des MVC-Musters gewählt, bei der der Controller lediglich Informationen aus Events der View verarbeitet und an das Modell weiterleitet. Für den zweiten Kommunikationsweg, vom Modell zur View, wurde eine separat zu implementierende Komponente gewählt: Der Adapter. Die Abbildung \ref{fig:MVC} zeigt die einzelnen Komponenten und die Aufgaben der Kommunikationskomponenten auf.
In der Mitte der Abbildung \ref{fig:MVC} ist eine Trennlinie zu erkennen. Sie soll die physische, sowie logische Grenze zwischen der Server- und der Client-Komponente repräsentieren. Auch zu erkennen ist, dass Controller und Adapter über diese Grenzen hinweg operieren müssen. Die View befindet sich auf dem Client und bekommt Benutzereingaben und soll möglichst aktuelle Daten aus dem Modell zur Anzeige bringen. Währenddessen befindet sich das Datenmodell des Spiels auf dem Server und implementiert die Regeln den Spiels, die für eine Integrität der Daten sorgen. Nun gibt es die Möglichkeit, dass der Controller komplett auf dem Client implementiert wird. Dies bringt den Vorteil, dass eine einzige Klasse an einer Position im Code hat, die für einen Kommunikationsweg zuständig ist. Der große Nachteil kommt jedoch auf der Server-Seite zum tragen: Hier muss das Modell stark an die Nachrichten des Controllers binden und Kommunikation im Datenmodell durchführen.  
Wenn dagegen der geteilte Ansatz eines Controller-Senders und -Empfängers gewählt wird, bleiben Nachrichten, also Kommunikation, auch in Klassen, die für Kommunikation zuständig sind und müssen nicht in anderen Klasse verarbeitet werden. Als Nachteil dieses Ansatzes ergibt sich der erhöhte Aufwand bei der Erstellung einer zusätzlichen Klasse. Die Vor- und Nachteile der Ansätze für den Entwurf des Controllers sind vollständig übertragbar auf den Adapter.\\
Es wurde sich im Folgenden für den Ansatz der geteilten Controller und Adapter entschieden, sodass sich 4 Klassen zur Kommunikation zwischen Ansicht und Datenmodell ergeben: Jeweils ein Controller und ein Adapter auf Server- \bzw
Client-Seite. Die Aufgaben der Klassen sind bereits in Abbildung \ref{fig:MVC} an den Pfeilen abzulesen.\\
Aus den Anpassungen für die Kommunikation ergibt sich damit der Aufbau aus Abbildung \ref{fig:ArchitekturSplit}.
\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=1\textwidth]{BasisArchitekturSplit}
	\caption[ArchitekturSplit]{Aufgeteilte Kommunikationsklassen}
	\label{fig:ArchitekturSplit}
\end{figure}

\noindent Da zur Kommunikation von Daten zwangläufig auch zu übertragende Daten gehören muss das Datenmodell so gestaltet werden, dass immer auf die aktuellen Daten zugegriffen werden kann. Außerdem müssen die Daten in einem Format vorliegen, dass eine Übertragung erlaubt. Da gleichzeitig lesender Zugriff im Client und schreibender Zugriff im Server auf die komplette Datenhaltung möglich sein muss, bietet es sich an ein zentrales Modell aufzustellen. Das zentrale Modell wird dann in einem Initialzustand vom Server an den Client gesendet. Im Spielbetrieb müssen dann nur noch Aktualisierungen übertragen werden, was die Last der Kommunikationswege deutlich reduziert. Da das Datenmodell stark an das, eingangs dieses Kapitels, aufgestellte Begriffsmodell angelehnt sein muss, ist schnell ersichtlich welche Menge an Daten und auch welche Daten vorgehalten werden müssen.
Die Abbildung \ref{fig:InfoModel} zeigt die gewählten Daten-Schnittstellen für das Datenmodell. 
\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.9\textwidth]{InfoModel}
	\caption[InfoModel]{Daten-Schnittstellen für Datenmodell}
	\label{fig:InfoModel}
\end{figure}
\clearpage
\noindent Die Daten-Schnittstellen enthalten keine Methoden. Sie sind nur Container \bzw Verträge für Daten. Die Schnittstellen für die Einstellungen und die Zauber besitzen keine direkten Beziehungen zu den anderen Schnittstellen, sondern stellen ihre Beziehungen erst durch die Regeln des Spiels her. Die Ausarbeitung der Daten für die einzelnen Schnittstellen ergibt sich aus dem Begriffsmodell und der Beschreibung des Spiels. Die meisten Schnittstellen werden zur gebündelten Übertragung in der Schnittstelle IGameModel vereint:


\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.6\textwidth]{IGameModel}
	\caption[IGameModel]{Daten-Schnittstelle IGameModel}
	\label{fig:IGameModel}
\end{figure}
\noindent Zu jeder Daten-Schnittstelle müssen jetzt die passenden Klassen für Anzeige und Logik entworfen werden um die wesentlichen Teile der Grobarchitektur fertigzustellen. Zu jeder Info-Schnittstelle gibt es also zwei weitere Klassen \zB zur IBoardInfo-Schnittstelle die Klassen Board für Spiellogik im Server und BoardView zur Anzeige im Client. Die Komponenten View und Modell werden im Folgenden nacheinander vorgestellt.
\clearpage
\subsubsection{View}
\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=1\textwidth]{View_Class_Diagram}
	\caption[View]{leicht vereinfachtes Klassendiagramm der View}
	\label{fig:ClassesView}
\end{figure}

\noindent Die Abbildung \ref{fig:ClassesView} zeigt eine leicht vereinfachte Darstellung der View-Komponente. Die Vereinfachungen bestehen in der reduzierten Darstellung der Anzeige-Klassen für die einzelnen Figurentypen. Exemplarisch sind hier nur die Typen "Knight", "Manticore", "Sorceress" und "Unicorn" dargestellt, da sich die Klassen nur in der Implementierung ihres Konstruktors unterscheiden, der das eigentliche 3D-Objekt anhand eines Informationsobjektes aus dem Datenmodell erzeugt.\\
Für den "ViewBuilder" wurde der Ansatz einer Injektionsmethode zur Anbindung an das Datenmodell gewählt. Damit kann die Objekt-Erzeugung vom Zeitpunkt der Injektion der Abhängigkeit entkoppelt werden. Das ist hier sinnvoll, da das Datenmodell zu einem Zeitpunkt zum Client gesendet wird, den dieser nicht beeinflussen kann. Der "ViewBuilder" hat die Aufgabe die einzelnen Erzeugungen von Anzeigeobjekten von der View zu entkoppeln, was den einfacheren Tausch eines Frameworks für die 3D-Objekte erlaubt und die bessere Bündelung von Abhängigkeiten möglich macht. Außerdem entkoppelt er die View von der Kenntnis über ein Datenmodell, sodass diese lediglich Anzeigeobjekte besitzt und auch nur für deren Aktualisierungen und tatsächliche Anzeige zuständig ist.\\
Desweiteren besitzen alle Anzeigeklassen eine Referenz auf ihr Informationsobjekt aus dem Datenmodell, sodass der Adapter Änderungen nur in das Modell auf dem Client laden muss und die View alle ihre Anzeigeobjekte in einer Schleife regelmäßig zu Aktualisierungen auffordert. Die einzelnen Anzeigeklassen interpretieren dabei die Informationen aus ihren Datenobjekten und wandeln diese in eine passende Darstellung basierend auf dem gewählten 3D-Framework.\\

\subsubsection{Modell}
\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=1\textwidth]{Modell_Class_Diagram}
	\caption[Modell]{Klassendiagramm des Modells}
	\label{fig:ClassesModell}
\end{figure}

\noindent Das Modell wurde sehr ähnlich zur View strukturiert. Die Klasse "ModelBuilder" ist für die korrekte Erzeugung eines Initialzustandes des Datenmodells zuständig. Während die Klasse "GameModel" die Erzeugung der Logik-Objekte selbst übernimmt, da diese keine aufwändigen Initialisierungsroutinen besitzen. Jedes Logik-Objekt kann auf sein Informationsobjekt zugreifen und besitzt Methoden zum Schreiben der Daten. Die Methoden sind dabei zuständig für das Überprüfen von Spielregeln, wie die Reichweite von Figuren oder das Ändern der Farbe der Felder auf dem Spielbrett.

An dieser Stelle sei noch die Benutzung des Beobachter-Musters zu erwähnen. Die Klasse "GameModel" muss den Adapter nach der Änderung von Daten informieren können, sodass der Adapter die geänderten Daten an den Client senden kann. Dafür trägt sich der Adapter in die Liste der Beobachter im "GameModel" ein und wird anschließend mittels der "notify"-Methode vom "GameModel" darüber benachrichtigt welche Daten sich geändert haben und kann die Änderungen einfach weiterleiten.

Da nun alle wesentlichen Komponenten des System und deren Aufbau beschrieben wurden, bleibt nun die Ansicht der technologischen Abhängigkeiten zu zeigen.\\
Zu sehen ist, dass die erwähnten Dev-Dependencies der Node.js-Umgebung auch im Client benutzt werden. Dies wird durch die Benutzung eines Paketes zur Bündelung und Minimierung der JavaScript-Dateien im Client ermöglicht: Browserify. Browserify wird dabei mit dem Paket tsify kombiniert um den Typescript-Code vorher bündeln und in JavaScript zu konvertieren.

Außerdem sind die Abhängigkeiten zu Jest und Chai in Abbildung \ref{fig:ComponentDependencies} aufgezeigt. Jest ist eine Bibliothek, die eine Umgebung für den Test von JavaScript-Code bereitstellt, es werden dabei auch Berichte über den Erfolg von Tests und die Abdeckungsrate der Tests erstellt. Chai ist eine Bibliothek, die weitere Methoden für das Abfragen in Tests bereitstellt und damit das Test von JavaScript-Code weiter beschleunigt und vereinfacht.

\subsubsection{Abhängigkeiten}
\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=1\textwidth]{Dependencies}
	\caption[Abhängigkeiten]{Komponentendiagramm der Abhängigkeiten}
	\label{fig:ComponentDependencies}
\end{figure}
\noindent Die Grafik \ref{fig:ComponentDependencies} zeigt eine Übersicht über die Abhängigkeiten des Servers und des Clients zu den gewählten Frameworks und Software-Bibliotheken. Da deren Verwendung schon in Kapitel \ref{subsec:Technologien} \bzw \ref{subsec:Hilfsmittel} erläutert wurde dient diese Übersicht nur noch einmal zur Visualisierung und als Einstieg für die Implementierung der Architektur im folgenden Abschnitt.

\subsection{Schritte der Implementierung}
\label{subsec:Implementierung}\index{Implementierung}

Bei der Implementierung wurde sich zunächst mit den einzelnen Technologien aus der Grafik \ref{fig:ComponentDependencies} vertraut gemacht. Dafür wurden verschiedene Beispiele herangezogen und die Dokumentation, sowie \ggf vorhandene Getting-Started-Guides durchgearbeitet.\footnote{So zum Beispiel für Socket.IO: \url{https://socket.io/get-started/chat/}}
Anschließend wurde die Entwicklungsumgebung aufgesetzt auf Basis eines Starter-Projektes für Node.js-Projekte mit Typescript und Express.\cite{typescript_node_starter} Dabei wurde das Starter-Projekt so angepasst, dass die Applikation auf das Bereitstellen von statischen Webseiten spezialisiert ist. Einige Skripte zum Erstellen, Debuggen, Bündeln und Minimieren der Applikation wurden angepasst \bzw hinzugefügt. Der Aufbau des Projektes wird im Folgenden näher erläutert.

\subsubsection{Projektaufbau}

\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.30\textwidth]{RootDirectory}
	\caption[Projektverzeichnis]{Das Projektverzeichnis}
	\label{fig:RootDirectory}
\end{figure}

\noindent Die Abbildung \ref{fig:RootDirectory} zeigt das Projektverzeichnis. Ordner sind dabei blau dargestellt und Dateien gelb.\\
Generell ist ein Projekt mit Node.js immer auf einer Datei mit dem Namen "package.json" aufgebaut. Diese Datei enthält neben wichtigen Meta-Informationen, wie dem Namen des Projektes und seiner Version, auch Informationen, wie bestimme Befehle wie ein Start, das Debuggen\footnote{Debugging beschreibt die Untersuchung einer laufenden Applikationen auf Fehler und deren Behebung} \etc ausgeführt werden sollen. Auch sind in dieser Datei die (Entwicklungs-)Abhängigkeiten enthalten. Dabei wird ein Paket immer mit seiner benutzen Version angegeben und möglichst große Portabilität zu erreichen und einen Projekt-Stand exakt reproduzieren zu können. Die Abbildung \ref{fig:Package} zeigt einen Ausschnitt der Datei. Dabei sind aus Übersichtsgründen die Abhängigkeiten und Skripte ausgeblendet.

\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.8\textwidth]{package}
	\caption[Package]{Ein Ausschnitt der Datei package.json}
	\label{fig:Package}
\end{figure}

\noindent Für die Verwaltung der Pakete und Abhängigkeiten wird dabei der Paketmanager npm\footnote{npm -- Node.js package manager, verwaltet das Laden, Aktualisieren und Einbinden von externen Paketen in ein Projekt} benutzt, der auch die Ausführung der in package.json eingetragenen Befehle und Skripte übernimmt. Die Befehle und Skripte dieses Projektes werden in Tabelle \ref{tab:Scripts} aufgelistet und beschrieben.\\
Alle weiteren Dateien mit der Endung \emph{.json} aus Abbildung \ref{fig:RootDirectory} stellen Konfigurationsdateien dar. Das Verzeichnis \emph{dist} enthält die gebaute Version der Applikation -- aus diesem Verzeichnis wird die Anwendung gestartet und es enthält alle fertigen Applikationsdateien. Das Verzeichnis \emph{test} enthält alle Dateien, die Tests definieren. Das Verzeichnis \emph{src} enthält alle Quelldateien. Die unterliegende Struktur des Verzeichnisses \emph{src} wird beim Bau der Applikation immer auf das Verzeichnis \emph{dist} übertragen.\clearpage

\begin{table}
	\centering
	\begin{tabular}{|l| p{10cm}|}
		\hline
		\textbf{Befehl} & \textbf{Beschreibung} \\
		\hline \hline
		build 				& 	Baut die gesamte Applikation und führt bundle, sowie tslint aus, kopiert auch die statischen Dateien \\
		build-ts 			& 	konvertiert nur TypeScript in JavaScript \\
		bundle 				&	Minimiert, konvertiert und bündelt die Client-Komponente zu einer Datei bundle.js \\
		copy-static-assets 	& 	Kopiert statische Dateien wie Bibliotheken und Bilder mit Hilfe des Skriptes aus copyStaticAssets.ts in das Ausgabeverzeichnis \\
		createDiagrams 		& 	Erzeugt mit Hilfe des Pakets tsviz\footnotemark{} und Graphviz\footnotemark{} Klassendiagramme von diversen Unterverzeichnissen \\
		debug				&	Baut die Applikation und startet sie dann im Debug-Modus \\
		serve				&	Startet die Anwendung mit server.js als Einstiegspunkt \\
		serve-debug			&	Startet nodemon\footnotemark{}, welcher die Datei server.js nach Änderungen überwacht und automatisch die Anwendung neustartet \\
		start				&	Ein Alias für serve \\
		test				&	Startet jest und führt alle Testfälle aus und nimmt die Abdeckung auf \\
		tslint				&	Startet tslint und überprüft anhand von tsconfig.json den Code nach Lesbarkeit unf funktionalen Fehlern \\
		watch				&	Startet nodemon und überwacht Node.js und Typescript mittels Dateien, die eine Zuordnung von TypeScript zu JavaScript enthalten \\
		watch-*				&	überwacht jeweilige Dateien auf Änderungen, während die Applikation läuft. Baut und Startet die Applikation \ggf neu \\\hline
	\end{tabular}
	\captionsetup{justification=centering}
	\caption[Skripte]{Skripte aus package.json}
	\label{tab:Scripts}
\end{table}
\addtocounter{footnote}{-3} %3=n
\stepcounter{footnote}\footnotetext{tsviz -- Ein npm-Paket, dass aus Graphviz aufbaut und aus TypeScript-Code Klassendiagramme erzeugt}
\stepcounter{footnote}\footnotetext{Graphviz ist eine freie Visualisierungssoftware für Graphen und Diagramme jeglicher Art}
\stepcounter{footnote}\footnotetext{nodemon ist eine Applikation, die Dateiänderungen im Projektverzeichnis überwacht und daraufhin die Node.js-Umgebung neustartet}

\subsubsection{Anfänge der Entwicklung}

Zunächst ist auf Basis des Projektes eine HTML-Seite mit einem Canvas-Element angelegt worden, sowie ein Aufruft der Socket.IO-Bibliothek auf der Seite. Der Aufruf verbindet sich mit dem Webserver.\\
Passend dazu wurde eine einfache Klasse "Server" erstellt, die einen http-Server, sowie einen Websocket-Server bereitstellt und initialisiert. Die Abbildungen \ref{lst:html_index_first} und \ref{fig:basicServerCode} zeigen diese beiden Entwürfe respektive.
\clearpage
\lstset{language=HTML5,basicstyle=\footnotesize}
\begin{lstlisting}[caption={[Erste Index.html]\HTML HTML - Erster Prototyp der Einstiegseite}, label=lst:html_index_first]
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset=utf-8>
			<title>My first three.js app</title>
			<style>
				body { margin: 0; }
				canvas { width: 100%; height: 100% }
			</style>
		</head>
		<body>
			<script src="js/three.js"></script>
			<script src="/socket.io/socket.io.js"></script>
			<script>
				var socket = io();
			</script>
		</body>
	</html>
\end{lstlisting}

\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.75\textwidth]{basicServerCode}
	\caption[erster Server-Code]{Der anfängliche Webserver}
	\label{fig:basicServerCode}
\end{figure}

Die Abbildung \ref{lst:html_index_first} zeigt in in Zeile 15 dabei, wie der Aufruf der Socket.IO-Bibliothek erfolgt. Der Aufruf erzeugt automatisch eine Verbindung zum Webserver und stellt einen Socket bereit.
In Zeile 13 und 14 werden die externen Bibliotheken inkludiert.

Der Server aus Abbildung \ref{fig:basicServerCode} erzeugt zunächst eine Konfiguration des Express-Frameworks. Anschließend wird ein Http-Server erzeugt. Der Http-Server wird dann konfiguriert um auf Anfragen von Clients auf den Wurzelpfad der Webadresse mit der Seite "Index.html" zu antworten.\\
Anschließend wird der Socket-Server initialisiert auf Basis des Http-Servers. Die Ereignisse zur Verbindung und dem Beenden von Clients werden vorab nur mit Log-Einträgen gefüllt.


\subsubsection{Entwurf eines Layouts für den Client}

Als nächstes wurde das Layout und Design für den Client fertiggestellt. Dabei wurde sich an Vorlagen mit dem Framework Bootstrap orientiert. Es bietet den Vorteil, dass das Design direkt "responsive" ist, sich also an die Größe des Bildschirms (Display) und seiner Auflösung anpasst. Abbildung \ref{fig:layoutWebpage} zeigt die generelle Struktur der Webseite.\\
Die seitlichen Spalten, links und rechts, sind dabei für Nachrichten zu dem \bzw über den jeweiligen Spieler da. Die "Navbar" wurde zu einer Titelzeile, da es bei diesem Spiel nur eine statische Webseite gibt und daher keine Navigation benötigt wird. Der Footer wurde ebenfalls zu Gunsten von mehr Spielfläche im Zentrum entfernt, kann aber für Hinweise und ein Impressum wieder eingefügt werden. Wie bereits erwähnt stellt der mittlere Teil die Spielfläche dar. Die Spielfläche besteht dabei lediglich aus dem Canvas-Element.\\
Das Framework benutzt dabei ein Design, dass auf einem Raster aufbaut. Die Angaben in den Spalten stellen daher die Raster-Einheiten dar. Das Raster wird je nach Display-Größe dann so umsortiert, dass eine möglichst gute Erfahrung für den Nutzer entsteht. Auf kleinen Bildschirmen werden die seitlichen Spalten über \bzw unter der Spielfläche angeordnet, sodass die Spielfläche die gesamte Breite des Bildschirms einnimmt.\\
Es wurden außerdem noch folgende weitere Elemente aus dem Bootstrap-Framework direkt eingesetzt:

\begin{itemize}
	\item Modale Dialoge, um Einstellung machen zu lassen \bzw über Sieg und Niederlage zu informieren
	\item Panels und Listen für die Nachrichten an Spieler
	\item Buttons für den direkten Test von Funktionalitäten (diese wurden im Anschluss natürlich entfernt)
	\item Ein "Jumbotron" -- also eine große Box, mit farblicher Abhebung
\end{itemize}

\clearpage

\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.85\textwidth]{LayoutWebpage}
	\caption[Layout Webseite]{Die Layout-Vorlage mit Bootstrap\footnotemark}
	\label{fig:layoutWebpage}
\end{figure}
\footnotetext{\Quelle{\url{https://www.w3schools.com/bootstrap/bootstrap_templates.asp}}}

\subsubsection{Parallelisierung}

Durch eine Erzeugung mehrerer Kommunikationsobjekte und Datenmodelle, könnten mehrere Spiele gleichzeitig ausgeführt werden. In dieser Realisierung ist dies, außer in der Architektur, noch nicht berücksichtigt worden. Gründe dafür sind die möglichst aufwandsarme Erstimplementierung um Übersicht und Zeitkosten im Rahmen einer Abschlussarbeit zu halten. Das erfordert allerdings einen Umgang mit Nutzern, die außer den beiden Spielenden die Webseite aufrufen. Hier kommt wiederum das Layout und Design der Webseite, sowie das Bootstrap-Element "Jumbotron" zum Zug.\\
Clients, die sich nicht erfolgreich in ein Spiel verbinden können, weil dieses belegt ist, werden auf eine Webseite weitergeleitet, die dem Nutzer diese Information mitteilt. Die Abbildung \ref{fig:rejectedPage} zeigt die fertige Webseite für dieses Vorgehen.\\ Es wird außerdem eine neue Anforderung der Webseite gestartet, sobald ein aktiver Spieler die Verbindung schließt. Die Mitteilung über einen freien Platz, also die Aufforderung zum erneuten Anfordern der Webseite erteilt dabei der Webserver dem Client über ein Event der Socket-Kommunikation.

\clearpage

\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.85\textwidth]{rejectedPage}
	\caption[Webseite Abweisung]{Die Webseite für abgewiesene Nutzer}
	\label{fig:rejectedPage}
\end{figure}

\noindent Das Management der Clients \bzw Nutzer zeigt der Ablauf in Abbildung. 

\section{Resultate}
\label{sec:Resultate}\index{Resultate}

\emph{Hier soll dann ein Screenshot des Ergebnisses rein und erläutert werden, dass als nächste der Endstand mit seiner Architektur gezeigt wird und anschließend die Erfüllung aller Anforderungen sichergestellt wird. Als letztes (falls genug Zeit!) werden die (hoffentlich) programmierten Unit-Tests erwähnt, und deren Ergebnisse dargestellt.}

\subsection{Überprüfung der Software mit Unit-Tests}
\label{subsec:unittests}\index{Unittests}

Bei der Erstellung von Unittests\footnote{Unittests -- deutsch: Modultests werden benutzt um einzelne Komponenten auf Fehlerfreiheit zu überprüfen} wurde sich auf Server-Komponenten beschränkt. Es wurden Tests für die korrekte Erzeugung und das Hochlaufen der Server-Komponente geschrieben. Auch wurden Tests für die Initialisierung der Socket-Kommunikation geschrieben. Die Abbildung \ref{fig:ComTest} zeigt einen entsprechenden Testfall.

\begin{figure}[htp]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=0.8\textwidth]{socketConnectionTest}
	\caption[Socket-Test]{Ein Testfall zur Kommunikation}
	\label{fig:ComTest}
\end{figure}

\noindent Desweiteren wurde durch Unittests sichergestellt, dass der Initialzustand der Datenmodells richtig erzeugt wird. Dadurch wurden wesentliche Fehler im Grundbetrieb ausgeschlossen und eine möglichst fehlerfreie Server-Komponente erzeugt. Durch die erfolgreichen Unittests des Datenmodells konnten Initialisierungsfehler ausgeschlossen werden. Dies ist besonders wichtig, da auf Basis des initialen Datenmodells auch der Client aufgebaut wird.

Die Benutzung von Unittests hat stark zur Erfüllung der Anforderungen beigetragen, indem die Fehlerfreiheit essentieller Komponenten festgestellt wurde und nötige Änderungen frühzeitig erkannt wurden.

\subsection{Erfüllung der Anforderungen}
\label{subsec:erfullung_anforderungen}\index{Erfüllung}

\emph{Hier werden die Anforderungen aus dem Analyse-Teil aufgegriffen und mit der fertigen Anwendung und ihrer Architektur abgeglichen, also so was wie "die einzelnen Figuren und ihre Unterschiede, sind hier und hier da und da durch umgesetzt worden."}

\section{Fazit}
\label{sec:Fazit}\index{Fazit}